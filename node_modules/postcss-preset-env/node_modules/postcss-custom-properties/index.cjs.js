'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var postcss = _interopDefault(require('postcss'));
var valueParser = _interopDefault(require('postcss-values-parser'));
var fs = _interopDefault(require('fs'));
var path = _interopDefault(require('path'));

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

function parse(string) {
  return valueParser(string).parse();
}

function isBlockIgnored(ruleOrDeclaration) {
  var rule = ruleOrDeclaration.selector ? ruleOrDeclaration : ruleOrDeclaration.parent;
  return /(!\s*)?postcss-custom-properties:\s*off\b/i.test(rule.toString());
}

function isRuleIgnored(rule) {
  var previous = rule.prev();
  return Boolean(isBlockIgnored(rule) || previous && previous.type === 'comment' && /(!\s*)?postcss-custom-properties:\s*ignore\s+next\b/i.test(previous.text));
}

function getCustomPropertiesFromRoot(root, opts) {
  // initialize custom selectors
  const customPropertiesFromHtmlElement = {};
  const customPropertiesFromRootPseudo = {}; // for each html or :root rule

  root.nodes.slice().forEach(rule => {
    const customPropertiesObject = isHtmlRule(rule) ? customPropertiesFromHtmlElement : isRootRule(rule) ? customPropertiesFromRootPseudo : null; // for each custom property

    if (customPropertiesObject) {
      rule.nodes.slice().forEach(decl => {
        if (isCustomDecl(decl) && !isBlockIgnored(decl)) {
          const prop = decl.prop; // write the parsed value to the custom property

          customPropertiesObject[prop] = parse(decl.value).nodes; // conditionally remove the custom property declaration

          if (!opts.preserve) {
            decl.remove();
          }
        }
      }); // conditionally remove the empty html or :root rule

      if (!opts.preserve && isEmptyParent(rule) && !isBlockIgnored(rule)) {
        rule.remove();
      }
    }
  }); // return all custom properties, preferring :root properties over html properties

  return Object.assign({}, customPropertiesFromHtmlElement, customPropertiesFromRootPseudo);
} // match html and :root rules

const htmlSelectorRegExp = /^html$/i;
const rootSelectorRegExp = /^:root$/i;
const customPropertyRegExp = /^--[A-z][\w-]*$/; // whether the node is an html or :root rule

const isHtmlRule = node => node.type === 'rule' && htmlSelectorRegExp.test(node.selector) && Object(node.nodes).length;

const isRootRule = node => node.type === 'rule' && rootSelectorRegExp.test(node.selector) && Object(node.nodes).length; // whether the node is an custom property


const isCustomDecl = node => node.type === 'decl' && customPropertyRegExp.test(node.prop); // whether the node is a parent without children


const isEmptyParent = node => Object(node.nodes).length === 0;

/* Get Custom Properties from CSS File
/* ========================================================================== */

function getCustomPropertiesFromCSSFile(_x) {
  return _getCustomPropertiesFromCSSFile.apply(this, arguments);
}
/* Get Custom Properties from Object
/* ========================================================================== */


function _getCustomPropertiesFromCSSFile() {
  _getCustomPropertiesFromCSSFile = _asyncToGenerator(function* (from) {
    const css = yield readFile(from);
    const root = postcss.parse(css, {
      from
    });
    return getCustomPropertiesFromRoot(root, {
      preserve: true
    });
  });
  return _getCustomPropertiesFromCSSFile.apply(this, arguments);
}

function getCustomPropertiesFromObject(object) {
  const customProperties = Object.assign({}, Object(object).customProperties, Object(object)['custom-properties']);

  for (const key in customProperties) {
    customProperties[key] = parse(String(customProperties[key])).nodes;
  }

  return customProperties;
}
/* Get Custom Properties from JSON file
/* ========================================================================== */


function getCustomPropertiesFromJSONFile(_x2) {
  return _getCustomPropertiesFromJSONFile.apply(this, arguments);
}
/* Get Custom Properties from JS file
/* ========================================================================== */


function _getCustomPropertiesFromJSONFile() {
  _getCustomPropertiesFromJSONFile = _asyncToGenerator(function* (from) {
    const object = yield readJSON(from);
    return getCustomPropertiesFromObject(object);
  });
  return _getCustomPropertiesFromJSONFile.apply(this, arguments);
}

function getCustomPropertiesFromJSFile(_x3) {
  return _getCustomPropertiesFromJSFile.apply(this, arguments);
}
/* Get Custom Properties from Imports
/* ========================================================================== */


function _getCustomPropertiesFromJSFile() {
  _getCustomPropertiesFromJSFile = _asyncToGenerator(function* (from) {
    const object = yield Promise.resolve(require(from));
    return getCustomPropertiesFromOb